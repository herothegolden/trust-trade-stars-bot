# Trust Trade Stars Bot ‚Äî memberships + per-doc + info buttons
# python-telegram-bot==20.7
# Env: BOT_TOKEN, OWNER_USERNAME (no @), ADMIN_IDS="123,456"

from __future__ import annotations
import logging, os
from dataclasses import dataclass
from typing import Optional, List
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, LabeledPrice
from telegram.ext import (
    ApplicationBuilder, CommandHandler, CallbackQueryHandler,
    ContextTypes, PreCheckoutQueryHandler, MessageHandler, filters
)

BOT_TOKEN = os.getenv("BOT_TOKEN", "")
OWNER_USERNAME = os.getenv("OWNER_USERNAME", "YourUsername")
_admin_env = os.getenv("ADMIN_IDS", "").strip()
ADMIN_IDS: List[int] = [int(x.strip()) for x in _admin_env.split(",") if x.strip().isdigit()] if _admin_env else []

# ---------- Catalog ----------
@dataclass(frozen=True)
class Product:
    key: str
    title: str
    desc: str
    stars: int

MEMBERSHIP_TIERS: List[Product] = [
    Product("mem-free",     "Free Member",     "Monthly access tier (manual renewal).", 250),
    Product("mem-verified", "Verified Member", "Monthly access tier (manual renewal).", 550),
    Product("mem-pro",      "Pro Member",      "Monthly access tier (manual renewal).", 1500),
    Product("mem-vip",      "Vip Member",      "Monthly access tier (manual renewal).", 5000),
    Product("mem-king",     "The Oil King",    "Unlimited verifications + dedicated manager.", 300000),
]

PER_DOC = Product("verify", "Document Verification", "Per-document review. 24‚Äì48h result.", 150)

def find_product(key: str) -> Optional[Product]:
    if key == PER_DOC.key: return PER_DOC
    for p in MEMBERSHIP_TIERS:
        if p.key == key: return p
    return None

# ---------- Copy ----------
INTRO = (
    "üí† *Trust Trade Network*\n"
    "*Filter First. Trade Smarter.*\n\n"
    "We verify *LOIs, ICPOs, SCOs, POP, POF, crypto wallets, and mandates* across oil, gas, metals, agri, and more.\n\n"
    "Choose a package to pay with ‚≠êÔ∏è Telegram Stars.\n\n"
    "*Monthly tiers (manual renewal):*\n"
    "‚Ä¢ *Free Member* ‚Äî 250‚≠êÔ∏è ‚Äî no verifications; Free Members group\n"
    "‚Ä¢ *Verified Member* ‚Äî 550‚≠êÔ∏è ‚Äî up to 2 verifications/day; Verified group\n"
    "‚Ä¢ *Pro Member* ‚Äî 1500‚≠êÔ∏è ‚Äî up to 7 verifications/day; Pro group\n"
    "‚Ä¢ *Vip Member* ‚Äî 5000‚≠êÔ∏è ‚Äî up to 10 verifications/day; VIP group\n"
    "‚Ä¢ *The Oil King* ‚Äî 300,000‚≠êÔ∏è ‚Äî unlimited verifications + dedicated manager (details below)\n\n"
    f"*Per-document verification:* {PER_DOC.stars}‚≠êÔ∏è each.\n"
    f"After payment, DM *@{OWNER_USERNAME}* with ‚ÄúREADY + your name‚Äù.\n"
    "_Turnaround: 24‚Äì48h. Usage limits are managed manually at this stage._"
)

WHAT_WE_VERIFY = (
    "üîé *What we verify*\n"
    "‚Ä¢ Letters & offers: LOI, ICPO, SCO, SPA excerpts\n"
    "‚Ä¢ Performance proofs: POP/POF variants, bank letters (format sanity), transaction trails\n"
    "‚Ä¢ Identity & mandate chains: mandates, intermediaries, signatory roles\n"
    "‚Ä¢ Crypto: wallet provenance checks (basic heuristics), transfer proofs, custody claims\n"
    "‚Ä¢ Commodities: oil/petchem, metals, agri ‚Äî cross-check issuer, dates, tonnage, routing logic\n\n"
    "Outputs: PASS / FLAG / REJECT with brief rationale. Not a legal opinion."
)

KING_DETAILS = (
    "üëë *The Oil King ‚Äî 300,000‚≠êÔ∏è*\n"
    "Unlimited verifications, priority handling, and a dedicated manager who will:\n\n"
    "‚Ä¢ *Filter deals & mitigate risk* ‚Äî screen offers, spot falsified docs, reduce noise\n"
    "‚Ä¢ *Provide multilingual coverage* ‚Äî English/Russian/Korean with suppliers/refineries across RU/KZ/KR\n"
    "‚Ä¢ *Expand vetted supplier access* ‚Äî ties into major producers/logistics, esp. KZ metals/coal\n"
    "‚Ä¢ *Optimize settlement* ‚Äî assist compliant crypto rails where appropriate to reduce cross-border friction\n"
    "‚Ä¢ *Explore digital asset options* ‚Äî assess tokenized tools for capital/loyalty when strategically aligned\n\n"
    "Use this tier only if you expect active deal flow and want white-glove screening."
)

# ---------- Keyboards ----------
def membership_keyboard() -> InlineKeyboardMarkup:
    rows = [[InlineKeyboardButton(f"{p.title} ‚Äî {p.stars} ‚≠êÔ∏è", callback_data=f"buy:{p.key}")] for p in MEMBERSHIP_TIERS]
    rows.append([InlineKeyboardButton(f"{PER_DOC.title} ‚Äî {PER_DOC.stars} ‚≠êÔ∏è", callback_data=f"buy:{PER_DOC.key}")])
    rows.append([
        InlineKeyboardButton("‚ÑπÔ∏è What we verify", callback_data="info"),
        InlineKeyboardButton("üëë Oil King details", callback_data="king"),
    ])
    return InlineKeyboardMarkup(rows)

def again_keyboard(product: Optional[Product]=None) -> InlineKeyboardMarkup:
    if product and product.key != PER_DOC.key:
        return InlineKeyboardMarkup([
            [InlineKeyboardButton(f"‚ûï Pay per document ({PER_DOC.stars}‚≠êÔ∏è)", callback_data=f"buy:{PER_DOC.key}")],
            [InlineKeyboardButton(f"üîÅ Renew {product.title}", callback_data=f"buy:{product.key}")],
            [InlineKeyboardButton("‚ÑπÔ∏è What we verify", callback_data="info")],
        ])
    elif product and product.key == PER_DOC.key:
        return InlineKeyboardMarkup([
            [InlineKeyboardButton(f"‚ûï Pay another document ({PER_DOC.stars}‚≠êÔ∏è)", callback_data=f"buy:{PER_DOC.key}")],
            [InlineKeyboardButton("üè∑Ô∏è Buy/renew membership", callback_data="menu")],
            [InlineKeyboardButton("‚ÑπÔ∏è What we verify", callback_data="info")],
        ])
    else:
        return InlineKeyboardMarkup([[InlineKeyboardButton("üè∑Ô∏è Choose a package", callback_data="menu")]])

# ---------- Invoicing ----------
async def send_invoice(chat_id: int, product: Product, context: ContextTypes.DEFAULT_TYPE) -> None:
    prices = [LabeledPrice(label=product.title, amount=product.stars)]
    await context.bot.send_invoice(
        chat_id=chat_id,
        title=product.title,
        description=product.desc,
        payload=f"{product.key}:{product.stars}",
        provider_token="",   # Stars (digital goods)
        currency="XTR",
        prices=prices,
        is_flexible=False,
        start_parameter=product.key
    )

# ---------- Handlers ----------
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    arg = context.args[0] if context.args else None
    if arg:
        prod = find_product(arg.lower())
        if prod:
            await send_invoice(update.effective_chat.id, prod, context)
            return
    await update.effective_chat.send_message(INTRO, parse_mode="Markdown", reply_markup=membership_keyboard())

async def on_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    q = update.callback_query; await q.answer()
    await q.message.reply_text(INTRO, parse_mode="Markdown", reply_markup=membership_keyboard())

async def on_info(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    q = update.callback_query; await q.answer()
    await q.message.reply_text(WHAT_WE_VERIFY, parse_mode="Markdown")

async def on_king(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    q = update.callback_query; await q.answer()
    await q.message.reply_text(KING_DETAILS, parse_mode="Markdown")

async def on_buy_click(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    q = update.callback_query; await q.answer()
    key = (q.data or "").split(":", 1)[1]
    prod = find_product(key)
    if not prod:
        await q.message.reply_text("Unknown package. Use /start.")
        return
    await send_invoice(q.message.chat_id, prod, context)

async def precheckout(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await update.pre_checkout_query.answer(ok=True)

async def on_success(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    sp = update.message.successful_payment
    pkey = (sp.invoice_payload or "").split(":")[0]
    prod = find_product(pkey) or Product(pkey, pkey.title(), "", sp.total_amount)
    user = update.effective_user
    if prod.key.startswith("mem-"):
        msg = (
            "‚úÖ *Membership payment received.*\n\n"
            f"Tier: *{prod.title}*\n"
            f"Next: DM *@{OWNER_USERNAME}* with ‚ÄúREADY + your name‚Äù. "
            "We‚Äôll confirm your membership and collect your documents.\n\n"
            "_Monthly charge; renew manually next month._"
        )
    else:
        msg = (
            "‚úÖ *Payment received for document verification.*\n\n"
            f"Amount: *{sp.total_amount}‚≠êÔ∏è*\n"
            f"Next: DM *@{OWNER_USERNAME}* with ‚ÄúREADY + your name‚Äù. "
            "We‚Äôll collect your documents and start review."
        )
    await update.message.reply_text(msg, parse_mode="Markdown", reply_markup=again_keyboard(prod))

    if ADMIN_IDS:
        uname = f"@{user.username}" if user and user.username else f"user_id:{user.id if user else 'unknown'}"
        text = (
            "üí∏ Stars payment received\n\n"
            f"From: {uname}\n"
            f"Type: {'Membership' if prod.key.startswith('mem-') else 'Per-Document'}\n"
            f"Package: {prod.title}\n"
            f"Amount: {sp.total_amount} ‚≠êÔ∏è\n"
            f"Payload: {sp.invoice_payload}\n"
        )
        for a in ADMIN_IDS:
            try: await context.bot.send_message(chat_id=a, text=text)
            except Exception as e: logging.warning(f"Admin notify failed {a}: {e}")

def main():
    logging.basicConfig(format="%(asctime)s %(levelname)s %(message)s", level=logging.INFO)
    if not BOT_TOKEN: raise RuntimeError("BOT_TOKEN is not set.")
    app = ApplicationBuilder().token(BOT_TOKEN).build()
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("help", start))
    app.add_handler(CallbackQueryHandler(on_menu, pattern=r"^menu$"))
    app.add_handler(CallbackQueryHandler(on_info, pattern=r"^info$"))
    app.add_handler(CallbackQueryHandler(on_king, pattern=r"^king$"))
    app.add_handler(CallbackQueryHandler(on_buy_click, pattern=r"^buy:"))
    app.add_handler(PreCheckoutQueryHandler(precheckout))
    app.add_handler(MessageHandler(filters.SUCCESSFUL_PAYMENT, on_success))
    app.run_polling()

if __name__ == "__main__":
    main()
